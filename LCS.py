# Основной алгоритм взят из "https://www.geeksforgeeks.org/longest-common-substring-dp-29/"
from time import time # импортируем библиотеку времени, для того, чтобы засечь сколько работала программа
tic = time() # берем текущее время и записываем в переменную
my_file = open("string1.txt", "r", encoding='utf-8') # открываем файл на чтение
text = my_file.read() # считываем текст из файла в переменную
my_file.close() # закрываем файл

my_file = open("string2.txt", "r", encoding='utf-8') # открываем файл на чтение
text2 = my_file.read() # считываем текст из файла в переменную
my_file.close() # закрываем файл
def LCSubStr(X, Y, m, n):  #основная функция
	LCSuff = [[0 for k in range(n+1)] for l in range(m+1)] #создаем и зануляем данный двумерный массив
	result = 0  # создаем переменную результат и обнуляем. В ней будет хранится длина наибольшей общей подстроки
	k = 0 # создаем переменную К и обнуляем. В ней будет хранится последний номер элемента совпадающей общей подстроки
	for i in range(m + 1): # пробегаем по строчкам
		for j in range(n + 1): # пробегаем по столбцам
			if (i == 0 or j == 0): # если i или j равны нулю
				LCSuff[i][j] = 0 # зануляем
			elif (X[i-1] == Y[j-1]): #в противном случае, если предыдущие элементы по данной диагонали равнялись
				LCSuff[i][j] = LCSuff[i-1][j-1] + 1  # добавляем единицу в текущее значение массива
				if result < LCSuff[i][j]: # если "результат" меньше текущего значения массива
					result = LCSuff[i][j] # присваиваем "результату" данное число
					k = i # записываем номер
			else:
				LCSuff[i][j] = 0 # в других случаях зануляем
	print("Длина наибольшей общей подстроки:",result) # выводим длину наибольшей общей подсроки
	print('Наибольшая общая подстрока:"{}"'.format(X[k-result:k])) # срезом выводим наибольшую общую подстроку
	return None # возвращаем ничего

X = text  # записываем в Х тест из первого файла
Y = text2 # записываем в У текст из второго файла
m = len(X) # записываем длину Х
n = len(Y) # записываем длину У
LCSubStr(X, Y, m, n) # запускаем функцию
toc = time() # берем текущее время
print("Время работы программы:",toc-tic) # вычисляем время
